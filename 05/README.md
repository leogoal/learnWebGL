**几个问题**

*将顶点的其他（非坐标）数据-如颜色等-传入顶点着色器

>   WebGL 允许我们把顶点的坐标和其他数据打包到同一个缓冲区对象中，并通过某种机制分别访问缓冲区对象中不同类型的数据

>   gl.vertexAttribPointer()之参数 stride offset 理解

>   stride 指定相邻2个顶点间的字节数，默认为0（在缓冲区对象中，单个顶点的所有数据的字节数，也就是相邻2个顶点间的距离，即步进参数；如果缓存区对象中只有1种数据，设置为0即可）

>   offset 表示当前的数据项距离首个元素的距离

*发生在顶点着色器和片元着色器之前的从图形到片元的转化，又称为 图元光栅化

**varying 变量

>   varying 变量（其作用是从顶点着色器向片元着色器传输数据）

>   在 WebGL 中，如果顶点着色器与片元着色器中有类型和命名都相同的 varying 变量，那么顶点着色器赋给该变量的值就会被自动地传入片元着色器

>   准确地说，顶点着色器的 varying 变量，在传入片元着色器之前经过了内插过程（每个varying变量都会经过这样的内插过程），所以 顶点着色器的varying变量和片元着色器的varying变量并不是一回事

**顶点着色器和片元着色器之间地步骤

>   图形装配过程：将孤立地顶点坐标装配成几何图形。几何图形的类别由 gl.drawArrays()方法的第一个参数决定

>   光栅化过程：将装配好的几何图形转化为片元

**一旦光栅化过程结束后，程序就开始逐片元调用片元着色器，每调用一次，就处理一个片元；对于每个片元，片元着色器计算出该片元的颜色，并写入颜色缓冲区

>   光栅化过程生成的片元都是带有坐标信息的，调用片元着色器时，这些坐标信息也随着片元传了进去，我们可以通过片元着色器的内置变量来访问片元的坐标

>   gl_FragCoord（该内置变量的第1个和第2个分量表示片元在 <canvas> 窗口坐标系统中的坐标值）


*将图像（纹理）映射到图形或三维对象的表面上
>   纹理映射：将一张图像映射（贴）到一个几何图形的表面上去(也就是，根据纹理图像，为之前光栅化后的每个片元涂上合适的颜色)
>   纹素：组成纹理图像的像素，每个纹素的颜色都是用 RGB 或 RGBA 格式编码

**纹理映射步骤**
1.准备纹理图像

2.为几何图形设置纹理映射方式（纹理坐标概念）

3.加载纹理图像，并进行一些配置，以在 WebGL 中使用它

4.在片元着色器中将相应的纹素从纹理中抽取出来，并将纹素的颜色赋给片元

**纹理坐标（st坐标系统）**
>   纹理坐标是纹理图像上的坐标，通过纹理坐标可以在纹理图像上获取纹素颜色
>   左下（0.0, 0.0）    右下（1.0， 0.0）   右上（1.0， 1.0）   左上（0.0， 1.0）

